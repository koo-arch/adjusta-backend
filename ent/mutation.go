// Code generated by ent, DO NOT EDIT.

package ent

import (
	"context"
	"errors"
	"fmt"
	"sync"
	"time"

	"entgo.io/ent"
	"entgo.io/ent/dialect/sql"
	"github.com/google/uuid"
	"github.com/koo-arch/adjusta-backend/ent/calendar"
	"github.com/koo-arch/adjusta-backend/ent/event"
	"github.com/koo-arch/adjusta-backend/ent/jwtkey"
	"github.com/koo-arch/adjusta-backend/ent/oauthtoken"
	"github.com/koo-arch/adjusta-backend/ent/predicate"
	"github.com/koo-arch/adjusta-backend/ent/proposeddate"
	"github.com/koo-arch/adjusta-backend/ent/user"
)

const (
	// Operation types.
	OpCreate    = ent.OpCreate
	OpDelete    = ent.OpDelete
	OpDeleteOne = ent.OpDeleteOne
	OpUpdate    = ent.OpUpdate
	OpUpdateOne = ent.OpUpdateOne

	// Node types.
	TypeCalendar     = "Calendar"
	TypeEvent        = "Event"
	TypeJWTKey       = "JWTKey"
	TypeOAuthToken   = "OAuthToken"
	TypeProposedDate = "ProposedDate"
	TypeUser         = "User"
)

// CalendarMutation represents an operation that mutates the Calendar nodes in the graph.
type CalendarMutation struct {
	config
	op            Op
	typ           string
	id            *uuid.UUID
	calendar_id   *string
	summary       *string
	is_primary    *bool
	clearedFields map[string]struct{}
	user          *uuid.UUID
	cleareduser   bool
	events        map[uuid.UUID]struct{}
	removedevents map[uuid.UUID]struct{}
	clearedevents bool
	done          bool
	oldValue      func(context.Context) (*Calendar, error)
	predicates    []predicate.Calendar
}

var _ ent.Mutation = (*CalendarMutation)(nil)

// calendarOption allows management of the mutation configuration using functional options.
type calendarOption func(*CalendarMutation)

// newCalendarMutation creates new mutation for the Calendar entity.
func newCalendarMutation(c config, op Op, opts ...calendarOption) *CalendarMutation {
	m := &CalendarMutation{
		config:        c,
		op:            op,
		typ:           TypeCalendar,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withCalendarID sets the ID field of the mutation.
func withCalendarID(id uuid.UUID) calendarOption {
	return func(m *CalendarMutation) {
		var (
			err   error
			once  sync.Once
			value *Calendar
		)
		m.oldValue = func(ctx context.Context) (*Calendar, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Calendar.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withCalendar sets the old Calendar of the mutation.
func withCalendar(node *Calendar) calendarOption {
	return func(m *CalendarMutation) {
		m.oldValue = func(context.Context) (*Calendar, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m CalendarMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m CalendarMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Calendar entities.
func (m *CalendarMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *CalendarMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *CalendarMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Calendar.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCalendarID sets the "calendar_id" field.
func (m *CalendarMutation) SetCalendarID(s string) {
	m.calendar_id = &s
}

// CalendarID returns the value of the "calendar_id" field in the mutation.
func (m *CalendarMutation) CalendarID() (r string, exists bool) {
	v := m.calendar_id
	if v == nil {
		return
	}
	return *v, true
}

// OldCalendarID returns the old "calendar_id" field's value of the Calendar entity.
// If the Calendar object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CalendarMutation) OldCalendarID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCalendarID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCalendarID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCalendarID: %w", err)
	}
	return oldValue.CalendarID, nil
}

// ResetCalendarID resets all changes to the "calendar_id" field.
func (m *CalendarMutation) ResetCalendarID() {
	m.calendar_id = nil
}

// SetSummary sets the "summary" field.
func (m *CalendarMutation) SetSummary(s string) {
	m.summary = &s
}

// Summary returns the value of the "summary" field in the mutation.
func (m *CalendarMutation) Summary() (r string, exists bool) {
	v := m.summary
	if v == nil {
		return
	}
	return *v, true
}

// OldSummary returns the old "summary" field's value of the Calendar entity.
// If the Calendar object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CalendarMutation) OldSummary(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSummary is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSummary requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSummary: %w", err)
	}
	return oldValue.Summary, nil
}

// ResetSummary resets all changes to the "summary" field.
func (m *CalendarMutation) ResetSummary() {
	m.summary = nil
}

// SetIsPrimary sets the "is_primary" field.
func (m *CalendarMutation) SetIsPrimary(b bool) {
	m.is_primary = &b
}

// IsPrimary returns the value of the "is_primary" field in the mutation.
func (m *CalendarMutation) IsPrimary() (r bool, exists bool) {
	v := m.is_primary
	if v == nil {
		return
	}
	return *v, true
}

// OldIsPrimary returns the old "is_primary" field's value of the Calendar entity.
// If the Calendar object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CalendarMutation) OldIsPrimary(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsPrimary is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsPrimary requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsPrimary: %w", err)
	}
	return oldValue.IsPrimary, nil
}

// ResetIsPrimary resets all changes to the "is_primary" field.
func (m *CalendarMutation) ResetIsPrimary() {
	m.is_primary = nil
}

// SetUserID sets the "user" edge to the User entity by id.
func (m *CalendarMutation) SetUserID(id uuid.UUID) {
	m.user = &id
}

// ClearUser clears the "user" edge to the User entity.
func (m *CalendarMutation) ClearUser() {
	m.cleareduser = true
}

// UserCleared reports if the "user" edge to the User entity was cleared.
func (m *CalendarMutation) UserCleared() bool {
	return m.cleareduser
}

// UserID returns the "user" edge ID in the mutation.
func (m *CalendarMutation) UserID() (id uuid.UUID, exists bool) {
	if m.user != nil {
		return *m.user, true
	}
	return
}

// UserIDs returns the "user" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UserID instead. It exists only for internal usage by the builders.
func (m *CalendarMutation) UserIDs() (ids []uuid.UUID) {
	if id := m.user; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUser resets all changes to the "user" edge.
func (m *CalendarMutation) ResetUser() {
	m.user = nil
	m.cleareduser = false
}

// AddEventIDs adds the "events" edge to the Event entity by ids.
func (m *CalendarMutation) AddEventIDs(ids ...uuid.UUID) {
	if m.events == nil {
		m.events = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.events[ids[i]] = struct{}{}
	}
}

// ClearEvents clears the "events" edge to the Event entity.
func (m *CalendarMutation) ClearEvents() {
	m.clearedevents = true
}

// EventsCleared reports if the "events" edge to the Event entity was cleared.
func (m *CalendarMutation) EventsCleared() bool {
	return m.clearedevents
}

// RemoveEventIDs removes the "events" edge to the Event entity by IDs.
func (m *CalendarMutation) RemoveEventIDs(ids ...uuid.UUID) {
	if m.removedevents == nil {
		m.removedevents = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.events, ids[i])
		m.removedevents[ids[i]] = struct{}{}
	}
}

// RemovedEvents returns the removed IDs of the "events" edge to the Event entity.
func (m *CalendarMutation) RemovedEventsIDs() (ids []uuid.UUID) {
	for id := range m.removedevents {
		ids = append(ids, id)
	}
	return
}

// EventsIDs returns the "events" edge IDs in the mutation.
func (m *CalendarMutation) EventsIDs() (ids []uuid.UUID) {
	for id := range m.events {
		ids = append(ids, id)
	}
	return
}

// ResetEvents resets all changes to the "events" edge.
func (m *CalendarMutation) ResetEvents() {
	m.events = nil
	m.clearedevents = false
	m.removedevents = nil
}

// Where appends a list predicates to the CalendarMutation builder.
func (m *CalendarMutation) Where(ps ...predicate.Calendar) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the CalendarMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *CalendarMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Calendar, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *CalendarMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *CalendarMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Calendar).
func (m *CalendarMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *CalendarMutation) Fields() []string {
	fields := make([]string, 0, 3)
	if m.calendar_id != nil {
		fields = append(fields, calendar.FieldCalendarID)
	}
	if m.summary != nil {
		fields = append(fields, calendar.FieldSummary)
	}
	if m.is_primary != nil {
		fields = append(fields, calendar.FieldIsPrimary)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *CalendarMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case calendar.FieldCalendarID:
		return m.CalendarID()
	case calendar.FieldSummary:
		return m.Summary()
	case calendar.FieldIsPrimary:
		return m.IsPrimary()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *CalendarMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case calendar.FieldCalendarID:
		return m.OldCalendarID(ctx)
	case calendar.FieldSummary:
		return m.OldSummary(ctx)
	case calendar.FieldIsPrimary:
		return m.OldIsPrimary(ctx)
	}
	return nil, fmt.Errorf("unknown Calendar field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CalendarMutation) SetField(name string, value ent.Value) error {
	switch name {
	case calendar.FieldCalendarID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCalendarID(v)
		return nil
	case calendar.FieldSummary:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSummary(v)
		return nil
	case calendar.FieldIsPrimary:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsPrimary(v)
		return nil
	}
	return fmt.Errorf("unknown Calendar field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *CalendarMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *CalendarMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CalendarMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Calendar numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *CalendarMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *CalendarMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *CalendarMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Calendar nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *CalendarMutation) ResetField(name string) error {
	switch name {
	case calendar.FieldCalendarID:
		m.ResetCalendarID()
		return nil
	case calendar.FieldSummary:
		m.ResetSummary()
		return nil
	case calendar.FieldIsPrimary:
		m.ResetIsPrimary()
		return nil
	}
	return fmt.Errorf("unknown Calendar field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *CalendarMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.user != nil {
		edges = append(edges, calendar.EdgeUser)
	}
	if m.events != nil {
		edges = append(edges, calendar.EdgeEvents)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *CalendarMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case calendar.EdgeUser:
		if id := m.user; id != nil {
			return []ent.Value{*id}
		}
	case calendar.EdgeEvents:
		ids := make([]ent.Value, 0, len(m.events))
		for id := range m.events {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *CalendarMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removedevents != nil {
		edges = append(edges, calendar.EdgeEvents)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *CalendarMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case calendar.EdgeEvents:
		ids := make([]ent.Value, 0, len(m.removedevents))
		for id := range m.removedevents {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *CalendarMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.cleareduser {
		edges = append(edges, calendar.EdgeUser)
	}
	if m.clearedevents {
		edges = append(edges, calendar.EdgeEvents)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *CalendarMutation) EdgeCleared(name string) bool {
	switch name {
	case calendar.EdgeUser:
		return m.cleareduser
	case calendar.EdgeEvents:
		return m.clearedevents
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *CalendarMutation) ClearEdge(name string) error {
	switch name {
	case calendar.EdgeUser:
		m.ClearUser()
		return nil
	}
	return fmt.Errorf("unknown Calendar unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *CalendarMutation) ResetEdge(name string) error {
	switch name {
	case calendar.EdgeUser:
		m.ResetUser()
		return nil
	case calendar.EdgeEvents:
		m.ResetEvents()
		return nil
	}
	return fmt.Errorf("unknown Calendar edge %s", name)
}

// EventMutation represents an operation that mutates the Event nodes in the graph.
type EventMutation struct {
	config
	op                    Op
	typ                   string
	id                    *uuid.UUID
	summary               *string
	description           *string
	location              *string
	status                *event.Status
	confirmed_date_id     *uuid.UUID
	clearedFields         map[string]struct{}
	calendar              *uuid.UUID
	clearedcalendar       bool
	proposed_dates        map[uuid.UUID]struct{}
	removedproposed_dates map[uuid.UUID]struct{}
	clearedproposed_dates bool
	done                  bool
	oldValue              func(context.Context) (*Event, error)
	predicates            []predicate.Event
}

var _ ent.Mutation = (*EventMutation)(nil)

// eventOption allows management of the mutation configuration using functional options.
type eventOption func(*EventMutation)

// newEventMutation creates new mutation for the Event entity.
func newEventMutation(c config, op Op, opts ...eventOption) *EventMutation {
	m := &EventMutation{
		config:        c,
		op:            op,
		typ:           TypeEvent,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withEventID sets the ID field of the mutation.
func withEventID(id uuid.UUID) eventOption {
	return func(m *EventMutation) {
		var (
			err   error
			once  sync.Once
			value *Event
		)
		m.oldValue = func(ctx context.Context) (*Event, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Event.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withEvent sets the old Event of the mutation.
func withEvent(node *Event) eventOption {
	return func(m *EventMutation) {
		m.oldValue = func(context.Context) (*Event, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m EventMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m EventMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Event entities.
func (m *EventMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *EventMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *EventMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Event.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetSummary sets the "summary" field.
func (m *EventMutation) SetSummary(s string) {
	m.summary = &s
}

// Summary returns the value of the "summary" field in the mutation.
func (m *EventMutation) Summary() (r string, exists bool) {
	v := m.summary
	if v == nil {
		return
	}
	return *v, true
}

// OldSummary returns the old "summary" field's value of the Event entity.
// If the Event object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EventMutation) OldSummary(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSummary is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSummary requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSummary: %w", err)
	}
	return oldValue.Summary, nil
}

// ClearSummary clears the value of the "summary" field.
func (m *EventMutation) ClearSummary() {
	m.summary = nil
	m.clearedFields[event.FieldSummary] = struct{}{}
}

// SummaryCleared returns if the "summary" field was cleared in this mutation.
func (m *EventMutation) SummaryCleared() bool {
	_, ok := m.clearedFields[event.FieldSummary]
	return ok
}

// ResetSummary resets all changes to the "summary" field.
func (m *EventMutation) ResetSummary() {
	m.summary = nil
	delete(m.clearedFields, event.FieldSummary)
}

// SetDescription sets the "description" field.
func (m *EventMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *EventMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the Event entity.
// If the Event object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EventMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "description" field.
func (m *EventMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[event.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "description" field was cleared in this mutation.
func (m *EventMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[event.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "description" field.
func (m *EventMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, event.FieldDescription)
}

// SetLocation sets the "location" field.
func (m *EventMutation) SetLocation(s string) {
	m.location = &s
}

// Location returns the value of the "location" field in the mutation.
func (m *EventMutation) Location() (r string, exists bool) {
	v := m.location
	if v == nil {
		return
	}
	return *v, true
}

// OldLocation returns the old "location" field's value of the Event entity.
// If the Event object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EventMutation) OldLocation(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLocation is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLocation requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLocation: %w", err)
	}
	return oldValue.Location, nil
}

// ClearLocation clears the value of the "location" field.
func (m *EventMutation) ClearLocation() {
	m.location = nil
	m.clearedFields[event.FieldLocation] = struct{}{}
}

// LocationCleared returns if the "location" field was cleared in this mutation.
func (m *EventMutation) LocationCleared() bool {
	_, ok := m.clearedFields[event.FieldLocation]
	return ok
}

// ResetLocation resets all changes to the "location" field.
func (m *EventMutation) ResetLocation() {
	m.location = nil
	delete(m.clearedFields, event.FieldLocation)
}

// SetStatus sets the "status" field.
func (m *EventMutation) SetStatus(e event.Status) {
	m.status = &e
}

// Status returns the value of the "status" field in the mutation.
func (m *EventMutation) Status() (r event.Status, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the Event entity.
// If the Event object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EventMutation) OldStatus(ctx context.Context) (v event.Status, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ResetStatus resets all changes to the "status" field.
func (m *EventMutation) ResetStatus() {
	m.status = nil
}

// SetConfirmedDateID sets the "confirmed_date_id" field.
func (m *EventMutation) SetConfirmedDateID(u uuid.UUID) {
	m.confirmed_date_id = &u
}

// ConfirmedDateID returns the value of the "confirmed_date_id" field in the mutation.
func (m *EventMutation) ConfirmedDateID() (r uuid.UUID, exists bool) {
	v := m.confirmed_date_id
	if v == nil {
		return
	}
	return *v, true
}

// OldConfirmedDateID returns the old "confirmed_date_id" field's value of the Event entity.
// If the Event object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EventMutation) OldConfirmedDateID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldConfirmedDateID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldConfirmedDateID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldConfirmedDateID: %w", err)
	}
	return oldValue.ConfirmedDateID, nil
}

// ClearConfirmedDateID clears the value of the "confirmed_date_id" field.
func (m *EventMutation) ClearConfirmedDateID() {
	m.confirmed_date_id = nil
	m.clearedFields[event.FieldConfirmedDateID] = struct{}{}
}

// ConfirmedDateIDCleared returns if the "confirmed_date_id" field was cleared in this mutation.
func (m *EventMutation) ConfirmedDateIDCleared() bool {
	_, ok := m.clearedFields[event.FieldConfirmedDateID]
	return ok
}

// ResetConfirmedDateID resets all changes to the "confirmed_date_id" field.
func (m *EventMutation) ResetConfirmedDateID() {
	m.confirmed_date_id = nil
	delete(m.clearedFields, event.FieldConfirmedDateID)
}

// SetCalendarID sets the "calendar" edge to the Calendar entity by id.
func (m *EventMutation) SetCalendarID(id uuid.UUID) {
	m.calendar = &id
}

// ClearCalendar clears the "calendar" edge to the Calendar entity.
func (m *EventMutation) ClearCalendar() {
	m.clearedcalendar = true
}

// CalendarCleared reports if the "calendar" edge to the Calendar entity was cleared.
func (m *EventMutation) CalendarCleared() bool {
	return m.clearedcalendar
}

// CalendarID returns the "calendar" edge ID in the mutation.
func (m *EventMutation) CalendarID() (id uuid.UUID, exists bool) {
	if m.calendar != nil {
		return *m.calendar, true
	}
	return
}

// CalendarIDs returns the "calendar" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// CalendarID instead. It exists only for internal usage by the builders.
func (m *EventMutation) CalendarIDs() (ids []uuid.UUID) {
	if id := m.calendar; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetCalendar resets all changes to the "calendar" edge.
func (m *EventMutation) ResetCalendar() {
	m.calendar = nil
	m.clearedcalendar = false
}

// AddProposedDateIDs adds the "proposed_dates" edge to the ProposedDate entity by ids.
func (m *EventMutation) AddProposedDateIDs(ids ...uuid.UUID) {
	if m.proposed_dates == nil {
		m.proposed_dates = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.proposed_dates[ids[i]] = struct{}{}
	}
}

// ClearProposedDates clears the "proposed_dates" edge to the ProposedDate entity.
func (m *EventMutation) ClearProposedDates() {
	m.clearedproposed_dates = true
}

// ProposedDatesCleared reports if the "proposed_dates" edge to the ProposedDate entity was cleared.
func (m *EventMutation) ProposedDatesCleared() bool {
	return m.clearedproposed_dates
}

// RemoveProposedDateIDs removes the "proposed_dates" edge to the ProposedDate entity by IDs.
func (m *EventMutation) RemoveProposedDateIDs(ids ...uuid.UUID) {
	if m.removedproposed_dates == nil {
		m.removedproposed_dates = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.proposed_dates, ids[i])
		m.removedproposed_dates[ids[i]] = struct{}{}
	}
}

// RemovedProposedDates returns the removed IDs of the "proposed_dates" edge to the ProposedDate entity.
func (m *EventMutation) RemovedProposedDatesIDs() (ids []uuid.UUID) {
	for id := range m.removedproposed_dates {
		ids = append(ids, id)
	}
	return
}

// ProposedDatesIDs returns the "proposed_dates" edge IDs in the mutation.
func (m *EventMutation) ProposedDatesIDs() (ids []uuid.UUID) {
	for id := range m.proposed_dates {
		ids = append(ids, id)
	}
	return
}

// ResetProposedDates resets all changes to the "proposed_dates" edge.
func (m *EventMutation) ResetProposedDates() {
	m.proposed_dates = nil
	m.clearedproposed_dates = false
	m.removedproposed_dates = nil
}

// Where appends a list predicates to the EventMutation builder.
func (m *EventMutation) Where(ps ...predicate.Event) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the EventMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *EventMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Event, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *EventMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *EventMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Event).
func (m *EventMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *EventMutation) Fields() []string {
	fields := make([]string, 0, 5)
	if m.summary != nil {
		fields = append(fields, event.FieldSummary)
	}
	if m.description != nil {
		fields = append(fields, event.FieldDescription)
	}
	if m.location != nil {
		fields = append(fields, event.FieldLocation)
	}
	if m.status != nil {
		fields = append(fields, event.FieldStatus)
	}
	if m.confirmed_date_id != nil {
		fields = append(fields, event.FieldConfirmedDateID)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *EventMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case event.FieldSummary:
		return m.Summary()
	case event.FieldDescription:
		return m.Description()
	case event.FieldLocation:
		return m.Location()
	case event.FieldStatus:
		return m.Status()
	case event.FieldConfirmedDateID:
		return m.ConfirmedDateID()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *EventMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case event.FieldSummary:
		return m.OldSummary(ctx)
	case event.FieldDescription:
		return m.OldDescription(ctx)
	case event.FieldLocation:
		return m.OldLocation(ctx)
	case event.FieldStatus:
		return m.OldStatus(ctx)
	case event.FieldConfirmedDateID:
		return m.OldConfirmedDateID(ctx)
	}
	return nil, fmt.Errorf("unknown Event field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *EventMutation) SetField(name string, value ent.Value) error {
	switch name {
	case event.FieldSummary:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSummary(v)
		return nil
	case event.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case event.FieldLocation:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLocation(v)
		return nil
	case event.FieldStatus:
		v, ok := value.(event.Status)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case event.FieldConfirmedDateID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetConfirmedDateID(v)
		return nil
	}
	return fmt.Errorf("unknown Event field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *EventMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *EventMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *EventMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Event numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *EventMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(event.FieldSummary) {
		fields = append(fields, event.FieldSummary)
	}
	if m.FieldCleared(event.FieldDescription) {
		fields = append(fields, event.FieldDescription)
	}
	if m.FieldCleared(event.FieldLocation) {
		fields = append(fields, event.FieldLocation)
	}
	if m.FieldCleared(event.FieldConfirmedDateID) {
		fields = append(fields, event.FieldConfirmedDateID)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *EventMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *EventMutation) ClearField(name string) error {
	switch name {
	case event.FieldSummary:
		m.ClearSummary()
		return nil
	case event.FieldDescription:
		m.ClearDescription()
		return nil
	case event.FieldLocation:
		m.ClearLocation()
		return nil
	case event.FieldConfirmedDateID:
		m.ClearConfirmedDateID()
		return nil
	}
	return fmt.Errorf("unknown Event nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *EventMutation) ResetField(name string) error {
	switch name {
	case event.FieldSummary:
		m.ResetSummary()
		return nil
	case event.FieldDescription:
		m.ResetDescription()
		return nil
	case event.FieldLocation:
		m.ResetLocation()
		return nil
	case event.FieldStatus:
		m.ResetStatus()
		return nil
	case event.FieldConfirmedDateID:
		m.ResetConfirmedDateID()
		return nil
	}
	return fmt.Errorf("unknown Event field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *EventMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.calendar != nil {
		edges = append(edges, event.EdgeCalendar)
	}
	if m.proposed_dates != nil {
		edges = append(edges, event.EdgeProposedDates)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *EventMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case event.EdgeCalendar:
		if id := m.calendar; id != nil {
			return []ent.Value{*id}
		}
	case event.EdgeProposedDates:
		ids := make([]ent.Value, 0, len(m.proposed_dates))
		for id := range m.proposed_dates {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *EventMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removedproposed_dates != nil {
		edges = append(edges, event.EdgeProposedDates)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *EventMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case event.EdgeProposedDates:
		ids := make([]ent.Value, 0, len(m.removedproposed_dates))
		for id := range m.removedproposed_dates {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *EventMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedcalendar {
		edges = append(edges, event.EdgeCalendar)
	}
	if m.clearedproposed_dates {
		edges = append(edges, event.EdgeProposedDates)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *EventMutation) EdgeCleared(name string) bool {
	switch name {
	case event.EdgeCalendar:
		return m.clearedcalendar
	case event.EdgeProposedDates:
		return m.clearedproposed_dates
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *EventMutation) ClearEdge(name string) error {
	switch name {
	case event.EdgeCalendar:
		m.ClearCalendar()
		return nil
	}
	return fmt.Errorf("unknown Event unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *EventMutation) ResetEdge(name string) error {
	switch name {
	case event.EdgeCalendar:
		m.ResetCalendar()
		return nil
	case event.EdgeProposedDates:
		m.ResetProposedDates()
		return nil
	}
	return fmt.Errorf("unknown Event edge %s", name)
}

// JWTKeyMutation represents an operation that mutates the JWTKey nodes in the graph.
type JWTKeyMutation struct {
	config
	op            Op
	typ           string
	id            *int
	key           *string
	_type         *string
	created_at    *time.Time
	expires_at    *time.Time
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*JWTKey, error)
	predicates    []predicate.JWTKey
}

var _ ent.Mutation = (*JWTKeyMutation)(nil)

// jwtkeyOption allows management of the mutation configuration using functional options.
type jwtkeyOption func(*JWTKeyMutation)

// newJWTKeyMutation creates new mutation for the JWTKey entity.
func newJWTKeyMutation(c config, op Op, opts ...jwtkeyOption) *JWTKeyMutation {
	m := &JWTKeyMutation{
		config:        c,
		op:            op,
		typ:           TypeJWTKey,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withJWTKeyID sets the ID field of the mutation.
func withJWTKeyID(id int) jwtkeyOption {
	return func(m *JWTKeyMutation) {
		var (
			err   error
			once  sync.Once
			value *JWTKey
		)
		m.oldValue = func(ctx context.Context) (*JWTKey, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().JWTKey.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withJWTKey sets the old JWTKey of the mutation.
func withJWTKey(node *JWTKey) jwtkeyOption {
	return func(m *JWTKeyMutation) {
		m.oldValue = func(context.Context) (*JWTKey, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m JWTKeyMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m JWTKeyMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *JWTKeyMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *JWTKeyMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().JWTKey.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetKey sets the "key" field.
func (m *JWTKeyMutation) SetKey(s string) {
	m.key = &s
}

// Key returns the value of the "key" field in the mutation.
func (m *JWTKeyMutation) Key() (r string, exists bool) {
	v := m.key
	if v == nil {
		return
	}
	return *v, true
}

// OldKey returns the old "key" field's value of the JWTKey entity.
// If the JWTKey object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *JWTKeyMutation) OldKey(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldKey is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldKey requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldKey: %w", err)
	}
	return oldValue.Key, nil
}

// ResetKey resets all changes to the "key" field.
func (m *JWTKeyMutation) ResetKey() {
	m.key = nil
}

// SetType sets the "type" field.
func (m *JWTKeyMutation) SetType(s string) {
	m._type = &s
}

// GetType returns the value of the "type" field in the mutation.
func (m *JWTKeyMutation) GetType() (r string, exists bool) {
	v := m._type
	if v == nil {
		return
	}
	return *v, true
}

// OldType returns the old "type" field's value of the JWTKey entity.
// If the JWTKey object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *JWTKeyMutation) OldType(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldType: %w", err)
	}
	return oldValue.Type, nil
}

// ResetType resets all changes to the "type" field.
func (m *JWTKeyMutation) ResetType() {
	m._type = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *JWTKeyMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *JWTKeyMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the JWTKey entity.
// If the JWTKey object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *JWTKeyMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *JWTKeyMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetExpiresAt sets the "expires_at" field.
func (m *JWTKeyMutation) SetExpiresAt(t time.Time) {
	m.expires_at = &t
}

// ExpiresAt returns the value of the "expires_at" field in the mutation.
func (m *JWTKeyMutation) ExpiresAt() (r time.Time, exists bool) {
	v := m.expires_at
	if v == nil {
		return
	}
	return *v, true
}

// OldExpiresAt returns the old "expires_at" field's value of the JWTKey entity.
// If the JWTKey object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *JWTKeyMutation) OldExpiresAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldExpiresAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldExpiresAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldExpiresAt: %w", err)
	}
	return oldValue.ExpiresAt, nil
}

// ResetExpiresAt resets all changes to the "expires_at" field.
func (m *JWTKeyMutation) ResetExpiresAt() {
	m.expires_at = nil
}

// Where appends a list predicates to the JWTKeyMutation builder.
func (m *JWTKeyMutation) Where(ps ...predicate.JWTKey) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the JWTKeyMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *JWTKeyMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.JWTKey, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *JWTKeyMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *JWTKeyMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (JWTKey).
func (m *JWTKeyMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *JWTKeyMutation) Fields() []string {
	fields := make([]string, 0, 4)
	if m.key != nil {
		fields = append(fields, jwtkey.FieldKey)
	}
	if m._type != nil {
		fields = append(fields, jwtkey.FieldType)
	}
	if m.created_at != nil {
		fields = append(fields, jwtkey.FieldCreatedAt)
	}
	if m.expires_at != nil {
		fields = append(fields, jwtkey.FieldExpiresAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *JWTKeyMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case jwtkey.FieldKey:
		return m.Key()
	case jwtkey.FieldType:
		return m.GetType()
	case jwtkey.FieldCreatedAt:
		return m.CreatedAt()
	case jwtkey.FieldExpiresAt:
		return m.ExpiresAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *JWTKeyMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case jwtkey.FieldKey:
		return m.OldKey(ctx)
	case jwtkey.FieldType:
		return m.OldType(ctx)
	case jwtkey.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case jwtkey.FieldExpiresAt:
		return m.OldExpiresAt(ctx)
	}
	return nil, fmt.Errorf("unknown JWTKey field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *JWTKeyMutation) SetField(name string, value ent.Value) error {
	switch name {
	case jwtkey.FieldKey:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetKey(v)
		return nil
	case jwtkey.FieldType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetType(v)
		return nil
	case jwtkey.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case jwtkey.FieldExpiresAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetExpiresAt(v)
		return nil
	}
	return fmt.Errorf("unknown JWTKey field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *JWTKeyMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *JWTKeyMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *JWTKeyMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown JWTKey numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *JWTKeyMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *JWTKeyMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *JWTKeyMutation) ClearField(name string) error {
	return fmt.Errorf("unknown JWTKey nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *JWTKeyMutation) ResetField(name string) error {
	switch name {
	case jwtkey.FieldKey:
		m.ResetKey()
		return nil
	case jwtkey.FieldType:
		m.ResetType()
		return nil
	case jwtkey.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case jwtkey.FieldExpiresAt:
		m.ResetExpiresAt()
		return nil
	}
	return fmt.Errorf("unknown JWTKey field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *JWTKeyMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *JWTKeyMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *JWTKeyMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *JWTKeyMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *JWTKeyMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *JWTKeyMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *JWTKeyMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown JWTKey unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *JWTKeyMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown JWTKey edge %s", name)
}

// OAuthTokenMutation represents an operation that mutates the OAuthToken nodes in the graph.
type OAuthTokenMutation struct {
	config
	op            Op
	typ           string
	id            *uuid.UUID
	access_token  *string
	refresh_token *string
	expiry        *time.Time
	clearedFields map[string]struct{}
	user          *uuid.UUID
	cleareduser   bool
	done          bool
	oldValue      func(context.Context) (*OAuthToken, error)
	predicates    []predicate.OAuthToken
}

var _ ent.Mutation = (*OAuthTokenMutation)(nil)

// oauthtokenOption allows management of the mutation configuration using functional options.
type oauthtokenOption func(*OAuthTokenMutation)

// newOAuthTokenMutation creates new mutation for the OAuthToken entity.
func newOAuthTokenMutation(c config, op Op, opts ...oauthtokenOption) *OAuthTokenMutation {
	m := &OAuthTokenMutation{
		config:        c,
		op:            op,
		typ:           TypeOAuthToken,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withOAuthTokenID sets the ID field of the mutation.
func withOAuthTokenID(id uuid.UUID) oauthtokenOption {
	return func(m *OAuthTokenMutation) {
		var (
			err   error
			once  sync.Once
			value *OAuthToken
		)
		m.oldValue = func(ctx context.Context) (*OAuthToken, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().OAuthToken.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withOAuthToken sets the old OAuthToken of the mutation.
func withOAuthToken(node *OAuthToken) oauthtokenOption {
	return func(m *OAuthTokenMutation) {
		m.oldValue = func(context.Context) (*OAuthToken, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m OAuthTokenMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m OAuthTokenMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of OAuthToken entities.
func (m *OAuthTokenMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *OAuthTokenMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *OAuthTokenMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().OAuthToken.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetAccessToken sets the "access_token" field.
func (m *OAuthTokenMutation) SetAccessToken(s string) {
	m.access_token = &s
}

// AccessToken returns the value of the "access_token" field in the mutation.
func (m *OAuthTokenMutation) AccessToken() (r string, exists bool) {
	v := m.access_token
	if v == nil {
		return
	}
	return *v, true
}

// OldAccessToken returns the old "access_token" field's value of the OAuthToken entity.
// If the OAuthToken object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OAuthTokenMutation) OldAccessToken(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAccessToken is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAccessToken requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAccessToken: %w", err)
	}
	return oldValue.AccessToken, nil
}

// ClearAccessToken clears the value of the "access_token" field.
func (m *OAuthTokenMutation) ClearAccessToken() {
	m.access_token = nil
	m.clearedFields[oauthtoken.FieldAccessToken] = struct{}{}
}

// AccessTokenCleared returns if the "access_token" field was cleared in this mutation.
func (m *OAuthTokenMutation) AccessTokenCleared() bool {
	_, ok := m.clearedFields[oauthtoken.FieldAccessToken]
	return ok
}

// ResetAccessToken resets all changes to the "access_token" field.
func (m *OAuthTokenMutation) ResetAccessToken() {
	m.access_token = nil
	delete(m.clearedFields, oauthtoken.FieldAccessToken)
}

// SetRefreshToken sets the "refresh_token" field.
func (m *OAuthTokenMutation) SetRefreshToken(s string) {
	m.refresh_token = &s
}

// RefreshToken returns the value of the "refresh_token" field in the mutation.
func (m *OAuthTokenMutation) RefreshToken() (r string, exists bool) {
	v := m.refresh_token
	if v == nil {
		return
	}
	return *v, true
}

// OldRefreshToken returns the old "refresh_token" field's value of the OAuthToken entity.
// If the OAuthToken object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OAuthTokenMutation) OldRefreshToken(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRefreshToken is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRefreshToken requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRefreshToken: %w", err)
	}
	return oldValue.RefreshToken, nil
}

// ClearRefreshToken clears the value of the "refresh_token" field.
func (m *OAuthTokenMutation) ClearRefreshToken() {
	m.refresh_token = nil
	m.clearedFields[oauthtoken.FieldRefreshToken] = struct{}{}
}

// RefreshTokenCleared returns if the "refresh_token" field was cleared in this mutation.
func (m *OAuthTokenMutation) RefreshTokenCleared() bool {
	_, ok := m.clearedFields[oauthtoken.FieldRefreshToken]
	return ok
}

// ResetRefreshToken resets all changes to the "refresh_token" field.
func (m *OAuthTokenMutation) ResetRefreshToken() {
	m.refresh_token = nil
	delete(m.clearedFields, oauthtoken.FieldRefreshToken)
}

// SetExpiry sets the "expiry" field.
func (m *OAuthTokenMutation) SetExpiry(t time.Time) {
	m.expiry = &t
}

// Expiry returns the value of the "expiry" field in the mutation.
func (m *OAuthTokenMutation) Expiry() (r time.Time, exists bool) {
	v := m.expiry
	if v == nil {
		return
	}
	return *v, true
}

// OldExpiry returns the old "expiry" field's value of the OAuthToken entity.
// If the OAuthToken object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OAuthTokenMutation) OldExpiry(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldExpiry is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldExpiry requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldExpiry: %w", err)
	}
	return oldValue.Expiry, nil
}

// ClearExpiry clears the value of the "expiry" field.
func (m *OAuthTokenMutation) ClearExpiry() {
	m.expiry = nil
	m.clearedFields[oauthtoken.FieldExpiry] = struct{}{}
}

// ExpiryCleared returns if the "expiry" field was cleared in this mutation.
func (m *OAuthTokenMutation) ExpiryCleared() bool {
	_, ok := m.clearedFields[oauthtoken.FieldExpiry]
	return ok
}

// ResetExpiry resets all changes to the "expiry" field.
func (m *OAuthTokenMutation) ResetExpiry() {
	m.expiry = nil
	delete(m.clearedFields, oauthtoken.FieldExpiry)
}

// SetUserID sets the "user" edge to the User entity by id.
func (m *OAuthTokenMutation) SetUserID(id uuid.UUID) {
	m.user = &id
}

// ClearUser clears the "user" edge to the User entity.
func (m *OAuthTokenMutation) ClearUser() {
	m.cleareduser = true
}

// UserCleared reports if the "user" edge to the User entity was cleared.
func (m *OAuthTokenMutation) UserCleared() bool {
	return m.cleareduser
}

// UserID returns the "user" edge ID in the mutation.
func (m *OAuthTokenMutation) UserID() (id uuid.UUID, exists bool) {
	if m.user != nil {
		return *m.user, true
	}
	return
}

// UserIDs returns the "user" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UserID instead. It exists only for internal usage by the builders.
func (m *OAuthTokenMutation) UserIDs() (ids []uuid.UUID) {
	if id := m.user; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUser resets all changes to the "user" edge.
func (m *OAuthTokenMutation) ResetUser() {
	m.user = nil
	m.cleareduser = false
}

// Where appends a list predicates to the OAuthTokenMutation builder.
func (m *OAuthTokenMutation) Where(ps ...predicate.OAuthToken) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the OAuthTokenMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *OAuthTokenMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.OAuthToken, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *OAuthTokenMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *OAuthTokenMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (OAuthToken).
func (m *OAuthTokenMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *OAuthTokenMutation) Fields() []string {
	fields := make([]string, 0, 3)
	if m.access_token != nil {
		fields = append(fields, oauthtoken.FieldAccessToken)
	}
	if m.refresh_token != nil {
		fields = append(fields, oauthtoken.FieldRefreshToken)
	}
	if m.expiry != nil {
		fields = append(fields, oauthtoken.FieldExpiry)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *OAuthTokenMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case oauthtoken.FieldAccessToken:
		return m.AccessToken()
	case oauthtoken.FieldRefreshToken:
		return m.RefreshToken()
	case oauthtoken.FieldExpiry:
		return m.Expiry()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *OAuthTokenMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case oauthtoken.FieldAccessToken:
		return m.OldAccessToken(ctx)
	case oauthtoken.FieldRefreshToken:
		return m.OldRefreshToken(ctx)
	case oauthtoken.FieldExpiry:
		return m.OldExpiry(ctx)
	}
	return nil, fmt.Errorf("unknown OAuthToken field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *OAuthTokenMutation) SetField(name string, value ent.Value) error {
	switch name {
	case oauthtoken.FieldAccessToken:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAccessToken(v)
		return nil
	case oauthtoken.FieldRefreshToken:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRefreshToken(v)
		return nil
	case oauthtoken.FieldExpiry:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetExpiry(v)
		return nil
	}
	return fmt.Errorf("unknown OAuthToken field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *OAuthTokenMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *OAuthTokenMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *OAuthTokenMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown OAuthToken numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *OAuthTokenMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(oauthtoken.FieldAccessToken) {
		fields = append(fields, oauthtoken.FieldAccessToken)
	}
	if m.FieldCleared(oauthtoken.FieldRefreshToken) {
		fields = append(fields, oauthtoken.FieldRefreshToken)
	}
	if m.FieldCleared(oauthtoken.FieldExpiry) {
		fields = append(fields, oauthtoken.FieldExpiry)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *OAuthTokenMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *OAuthTokenMutation) ClearField(name string) error {
	switch name {
	case oauthtoken.FieldAccessToken:
		m.ClearAccessToken()
		return nil
	case oauthtoken.FieldRefreshToken:
		m.ClearRefreshToken()
		return nil
	case oauthtoken.FieldExpiry:
		m.ClearExpiry()
		return nil
	}
	return fmt.Errorf("unknown OAuthToken nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *OAuthTokenMutation) ResetField(name string) error {
	switch name {
	case oauthtoken.FieldAccessToken:
		m.ResetAccessToken()
		return nil
	case oauthtoken.FieldRefreshToken:
		m.ResetRefreshToken()
		return nil
	case oauthtoken.FieldExpiry:
		m.ResetExpiry()
		return nil
	}
	return fmt.Errorf("unknown OAuthToken field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *OAuthTokenMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.user != nil {
		edges = append(edges, oauthtoken.EdgeUser)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *OAuthTokenMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case oauthtoken.EdgeUser:
		if id := m.user; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *OAuthTokenMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *OAuthTokenMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *OAuthTokenMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.cleareduser {
		edges = append(edges, oauthtoken.EdgeUser)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *OAuthTokenMutation) EdgeCleared(name string) bool {
	switch name {
	case oauthtoken.EdgeUser:
		return m.cleareduser
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *OAuthTokenMutation) ClearEdge(name string) error {
	switch name {
	case oauthtoken.EdgeUser:
		m.ClearUser()
		return nil
	}
	return fmt.Errorf("unknown OAuthToken unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *OAuthTokenMutation) ResetEdge(name string) error {
	switch name {
	case oauthtoken.EdgeUser:
		m.ResetUser()
		return nil
	}
	return fmt.Errorf("unknown OAuthToken edge %s", name)
}

// ProposedDateMutation represents an operation that mutates the ProposedDate nodes in the graph.
type ProposedDateMutation struct {
	config
	op              Op
	typ             string
	id              *uuid.UUID
	google_event_id *string
	start_time      *time.Time
	end_time        *time.Time
	priority        *int
	addpriority     *int
	clearedFields   map[string]struct{}
	event           *uuid.UUID
	clearedevent    bool
	done            bool
	oldValue        func(context.Context) (*ProposedDate, error)
	predicates      []predicate.ProposedDate
}

var _ ent.Mutation = (*ProposedDateMutation)(nil)

// proposeddateOption allows management of the mutation configuration using functional options.
type proposeddateOption func(*ProposedDateMutation)

// newProposedDateMutation creates new mutation for the ProposedDate entity.
func newProposedDateMutation(c config, op Op, opts ...proposeddateOption) *ProposedDateMutation {
	m := &ProposedDateMutation{
		config:        c,
		op:            op,
		typ:           TypeProposedDate,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withProposedDateID sets the ID field of the mutation.
func withProposedDateID(id uuid.UUID) proposeddateOption {
	return func(m *ProposedDateMutation) {
		var (
			err   error
			once  sync.Once
			value *ProposedDate
		)
		m.oldValue = func(ctx context.Context) (*ProposedDate, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().ProposedDate.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withProposedDate sets the old ProposedDate of the mutation.
func withProposedDate(node *ProposedDate) proposeddateOption {
	return func(m *ProposedDateMutation) {
		m.oldValue = func(context.Context) (*ProposedDate, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ProposedDateMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ProposedDateMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of ProposedDate entities.
func (m *ProposedDateMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ProposedDateMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ProposedDateMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().ProposedDate.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetGoogleEventID sets the "google_event_id" field.
func (m *ProposedDateMutation) SetGoogleEventID(s string) {
	m.google_event_id = &s
}

// GoogleEventID returns the value of the "google_event_id" field in the mutation.
func (m *ProposedDateMutation) GoogleEventID() (r string, exists bool) {
	v := m.google_event_id
	if v == nil {
		return
	}
	return *v, true
}

// OldGoogleEventID returns the old "google_event_id" field's value of the ProposedDate entity.
// If the ProposedDate object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProposedDateMutation) OldGoogleEventID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldGoogleEventID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldGoogleEventID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldGoogleEventID: %w", err)
	}
	return oldValue.GoogleEventID, nil
}

// ClearGoogleEventID clears the value of the "google_event_id" field.
func (m *ProposedDateMutation) ClearGoogleEventID() {
	m.google_event_id = nil
	m.clearedFields[proposeddate.FieldGoogleEventID] = struct{}{}
}

// GoogleEventIDCleared returns if the "google_event_id" field was cleared in this mutation.
func (m *ProposedDateMutation) GoogleEventIDCleared() bool {
	_, ok := m.clearedFields[proposeddate.FieldGoogleEventID]
	return ok
}

// ResetGoogleEventID resets all changes to the "google_event_id" field.
func (m *ProposedDateMutation) ResetGoogleEventID() {
	m.google_event_id = nil
	delete(m.clearedFields, proposeddate.FieldGoogleEventID)
}

// SetStartTime sets the "start_time" field.
func (m *ProposedDateMutation) SetStartTime(t time.Time) {
	m.start_time = &t
}

// StartTime returns the value of the "start_time" field in the mutation.
func (m *ProposedDateMutation) StartTime() (r time.Time, exists bool) {
	v := m.start_time
	if v == nil {
		return
	}
	return *v, true
}

// OldStartTime returns the old "start_time" field's value of the ProposedDate entity.
// If the ProposedDate object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProposedDateMutation) OldStartTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStartTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStartTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStartTime: %w", err)
	}
	return oldValue.StartTime, nil
}

// ResetStartTime resets all changes to the "start_time" field.
func (m *ProposedDateMutation) ResetStartTime() {
	m.start_time = nil
}

// SetEndTime sets the "end_time" field.
func (m *ProposedDateMutation) SetEndTime(t time.Time) {
	m.end_time = &t
}

// EndTime returns the value of the "end_time" field in the mutation.
func (m *ProposedDateMutation) EndTime() (r time.Time, exists bool) {
	v := m.end_time
	if v == nil {
		return
	}
	return *v, true
}

// OldEndTime returns the old "end_time" field's value of the ProposedDate entity.
// If the ProposedDate object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProposedDateMutation) OldEndTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEndTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEndTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEndTime: %w", err)
	}
	return oldValue.EndTime, nil
}

// ResetEndTime resets all changes to the "end_time" field.
func (m *ProposedDateMutation) ResetEndTime() {
	m.end_time = nil
}

// SetPriority sets the "priority" field.
func (m *ProposedDateMutation) SetPriority(i int) {
	m.priority = &i
	m.addpriority = nil
}

// Priority returns the value of the "priority" field in the mutation.
func (m *ProposedDateMutation) Priority() (r int, exists bool) {
	v := m.priority
	if v == nil {
		return
	}
	return *v, true
}

// OldPriority returns the old "priority" field's value of the ProposedDate entity.
// If the ProposedDate object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProposedDateMutation) OldPriority(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPriority is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPriority requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPriority: %w", err)
	}
	return oldValue.Priority, nil
}

// AddPriority adds i to the "priority" field.
func (m *ProposedDateMutation) AddPriority(i int) {
	if m.addpriority != nil {
		*m.addpriority += i
	} else {
		m.addpriority = &i
	}
}

// AddedPriority returns the value that was added to the "priority" field in this mutation.
func (m *ProposedDateMutation) AddedPriority() (r int, exists bool) {
	v := m.addpriority
	if v == nil {
		return
	}
	return *v, true
}

// ResetPriority resets all changes to the "priority" field.
func (m *ProposedDateMutation) ResetPriority() {
	m.priority = nil
	m.addpriority = nil
}

// SetEventID sets the "event" edge to the Event entity by id.
func (m *ProposedDateMutation) SetEventID(id uuid.UUID) {
	m.event = &id
}

// ClearEvent clears the "event" edge to the Event entity.
func (m *ProposedDateMutation) ClearEvent() {
	m.clearedevent = true
}

// EventCleared reports if the "event" edge to the Event entity was cleared.
func (m *ProposedDateMutation) EventCleared() bool {
	return m.clearedevent
}

// EventID returns the "event" edge ID in the mutation.
func (m *ProposedDateMutation) EventID() (id uuid.UUID, exists bool) {
	if m.event != nil {
		return *m.event, true
	}
	return
}

// EventIDs returns the "event" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// EventID instead. It exists only for internal usage by the builders.
func (m *ProposedDateMutation) EventIDs() (ids []uuid.UUID) {
	if id := m.event; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetEvent resets all changes to the "event" edge.
func (m *ProposedDateMutation) ResetEvent() {
	m.event = nil
	m.clearedevent = false
}

// Where appends a list predicates to the ProposedDateMutation builder.
func (m *ProposedDateMutation) Where(ps ...predicate.ProposedDate) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the ProposedDateMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *ProposedDateMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.ProposedDate, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *ProposedDateMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *ProposedDateMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (ProposedDate).
func (m *ProposedDateMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ProposedDateMutation) Fields() []string {
	fields := make([]string, 0, 4)
	if m.google_event_id != nil {
		fields = append(fields, proposeddate.FieldGoogleEventID)
	}
	if m.start_time != nil {
		fields = append(fields, proposeddate.FieldStartTime)
	}
	if m.end_time != nil {
		fields = append(fields, proposeddate.FieldEndTime)
	}
	if m.priority != nil {
		fields = append(fields, proposeddate.FieldPriority)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ProposedDateMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case proposeddate.FieldGoogleEventID:
		return m.GoogleEventID()
	case proposeddate.FieldStartTime:
		return m.StartTime()
	case proposeddate.FieldEndTime:
		return m.EndTime()
	case proposeddate.FieldPriority:
		return m.Priority()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ProposedDateMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case proposeddate.FieldGoogleEventID:
		return m.OldGoogleEventID(ctx)
	case proposeddate.FieldStartTime:
		return m.OldStartTime(ctx)
	case proposeddate.FieldEndTime:
		return m.OldEndTime(ctx)
	case proposeddate.FieldPriority:
		return m.OldPriority(ctx)
	}
	return nil, fmt.Errorf("unknown ProposedDate field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ProposedDateMutation) SetField(name string, value ent.Value) error {
	switch name {
	case proposeddate.FieldGoogleEventID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetGoogleEventID(v)
		return nil
	case proposeddate.FieldStartTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStartTime(v)
		return nil
	case proposeddate.FieldEndTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEndTime(v)
		return nil
	case proposeddate.FieldPriority:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPriority(v)
		return nil
	}
	return fmt.Errorf("unknown ProposedDate field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ProposedDateMutation) AddedFields() []string {
	var fields []string
	if m.addpriority != nil {
		fields = append(fields, proposeddate.FieldPriority)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ProposedDateMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case proposeddate.FieldPriority:
		return m.AddedPriority()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ProposedDateMutation) AddField(name string, value ent.Value) error {
	switch name {
	case proposeddate.FieldPriority:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddPriority(v)
		return nil
	}
	return fmt.Errorf("unknown ProposedDate numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ProposedDateMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(proposeddate.FieldGoogleEventID) {
		fields = append(fields, proposeddate.FieldGoogleEventID)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ProposedDateMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ProposedDateMutation) ClearField(name string) error {
	switch name {
	case proposeddate.FieldGoogleEventID:
		m.ClearGoogleEventID()
		return nil
	}
	return fmt.Errorf("unknown ProposedDate nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ProposedDateMutation) ResetField(name string) error {
	switch name {
	case proposeddate.FieldGoogleEventID:
		m.ResetGoogleEventID()
		return nil
	case proposeddate.FieldStartTime:
		m.ResetStartTime()
		return nil
	case proposeddate.FieldEndTime:
		m.ResetEndTime()
		return nil
	case proposeddate.FieldPriority:
		m.ResetPriority()
		return nil
	}
	return fmt.Errorf("unknown ProposedDate field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ProposedDateMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.event != nil {
		edges = append(edges, proposeddate.EdgeEvent)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ProposedDateMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case proposeddate.EdgeEvent:
		if id := m.event; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ProposedDateMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ProposedDateMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ProposedDateMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedevent {
		edges = append(edges, proposeddate.EdgeEvent)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ProposedDateMutation) EdgeCleared(name string) bool {
	switch name {
	case proposeddate.EdgeEvent:
		return m.clearedevent
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ProposedDateMutation) ClearEdge(name string) error {
	switch name {
	case proposeddate.EdgeEvent:
		m.ClearEvent()
		return nil
	}
	return fmt.Errorf("unknown ProposedDate unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ProposedDateMutation) ResetEdge(name string) error {
	switch name {
	case proposeddate.EdgeEvent:
		m.ResetEvent()
		return nil
	}
	return fmt.Errorf("unknown ProposedDate edge %s", name)
}

// UserMutation represents an operation that mutates the User nodes in the graph.
type UserMutation struct {
	config
	op                   Op
	typ                  string
	id                   *uuid.UUID
	email                *string
	refresh_token        *string
	refresh_token_expiry *time.Time
	clearedFields        map[string]struct{}
	oauth_token          *uuid.UUID
	clearedoauth_token   bool
	calendars            map[uuid.UUID]struct{}
	removedcalendars     map[uuid.UUID]struct{}
	clearedcalendars     bool
	done                 bool
	oldValue             func(context.Context) (*User, error)
	predicates           []predicate.User
}

var _ ent.Mutation = (*UserMutation)(nil)

// userOption allows management of the mutation configuration using functional options.
type userOption func(*UserMutation)

// newUserMutation creates new mutation for the User entity.
func newUserMutation(c config, op Op, opts ...userOption) *UserMutation {
	m := &UserMutation{
		config:        c,
		op:            op,
		typ:           TypeUser,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withUserID sets the ID field of the mutation.
func withUserID(id uuid.UUID) userOption {
	return func(m *UserMutation) {
		var (
			err   error
			once  sync.Once
			value *User
		)
		m.oldValue = func(ctx context.Context) (*User, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().User.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withUser sets the old User of the mutation.
func withUser(node *User) userOption {
	return func(m *UserMutation) {
		m.oldValue = func(context.Context) (*User, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m UserMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m UserMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of User entities.
func (m *UserMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *UserMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *UserMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().User.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetEmail sets the "email" field.
func (m *UserMutation) SetEmail(s string) {
	m.email = &s
}

// Email returns the value of the "email" field in the mutation.
func (m *UserMutation) Email() (r string, exists bool) {
	v := m.email
	if v == nil {
		return
	}
	return *v, true
}

// OldEmail returns the old "email" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldEmail(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEmail is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEmail requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEmail: %w", err)
	}
	return oldValue.Email, nil
}

// ResetEmail resets all changes to the "email" field.
func (m *UserMutation) ResetEmail() {
	m.email = nil
}

// SetRefreshToken sets the "refresh_token" field.
func (m *UserMutation) SetRefreshToken(s string) {
	m.refresh_token = &s
}

// RefreshToken returns the value of the "refresh_token" field in the mutation.
func (m *UserMutation) RefreshToken() (r string, exists bool) {
	v := m.refresh_token
	if v == nil {
		return
	}
	return *v, true
}

// OldRefreshToken returns the old "refresh_token" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldRefreshToken(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRefreshToken is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRefreshToken requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRefreshToken: %w", err)
	}
	return oldValue.RefreshToken, nil
}

// ClearRefreshToken clears the value of the "refresh_token" field.
func (m *UserMutation) ClearRefreshToken() {
	m.refresh_token = nil
	m.clearedFields[user.FieldRefreshToken] = struct{}{}
}

// RefreshTokenCleared returns if the "refresh_token" field was cleared in this mutation.
func (m *UserMutation) RefreshTokenCleared() bool {
	_, ok := m.clearedFields[user.FieldRefreshToken]
	return ok
}

// ResetRefreshToken resets all changes to the "refresh_token" field.
func (m *UserMutation) ResetRefreshToken() {
	m.refresh_token = nil
	delete(m.clearedFields, user.FieldRefreshToken)
}

// SetRefreshTokenExpiry sets the "refresh_token_expiry" field.
func (m *UserMutation) SetRefreshTokenExpiry(t time.Time) {
	m.refresh_token_expiry = &t
}

// RefreshTokenExpiry returns the value of the "refresh_token_expiry" field in the mutation.
func (m *UserMutation) RefreshTokenExpiry() (r time.Time, exists bool) {
	v := m.refresh_token_expiry
	if v == nil {
		return
	}
	return *v, true
}

// OldRefreshTokenExpiry returns the old "refresh_token_expiry" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldRefreshTokenExpiry(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRefreshTokenExpiry is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRefreshTokenExpiry requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRefreshTokenExpiry: %w", err)
	}
	return oldValue.RefreshTokenExpiry, nil
}

// ClearRefreshTokenExpiry clears the value of the "refresh_token_expiry" field.
func (m *UserMutation) ClearRefreshTokenExpiry() {
	m.refresh_token_expiry = nil
	m.clearedFields[user.FieldRefreshTokenExpiry] = struct{}{}
}

// RefreshTokenExpiryCleared returns if the "refresh_token_expiry" field was cleared in this mutation.
func (m *UserMutation) RefreshTokenExpiryCleared() bool {
	_, ok := m.clearedFields[user.FieldRefreshTokenExpiry]
	return ok
}

// ResetRefreshTokenExpiry resets all changes to the "refresh_token_expiry" field.
func (m *UserMutation) ResetRefreshTokenExpiry() {
	m.refresh_token_expiry = nil
	delete(m.clearedFields, user.FieldRefreshTokenExpiry)
}

// SetOauthTokenID sets the "oauth_token" edge to the OAuthToken entity by id.
func (m *UserMutation) SetOauthTokenID(id uuid.UUID) {
	m.oauth_token = &id
}

// ClearOauthToken clears the "oauth_token" edge to the OAuthToken entity.
func (m *UserMutation) ClearOauthToken() {
	m.clearedoauth_token = true
}

// OauthTokenCleared reports if the "oauth_token" edge to the OAuthToken entity was cleared.
func (m *UserMutation) OauthTokenCleared() bool {
	return m.clearedoauth_token
}

// OauthTokenID returns the "oauth_token" edge ID in the mutation.
func (m *UserMutation) OauthTokenID() (id uuid.UUID, exists bool) {
	if m.oauth_token != nil {
		return *m.oauth_token, true
	}
	return
}

// OauthTokenIDs returns the "oauth_token" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// OauthTokenID instead. It exists only for internal usage by the builders.
func (m *UserMutation) OauthTokenIDs() (ids []uuid.UUID) {
	if id := m.oauth_token; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetOauthToken resets all changes to the "oauth_token" edge.
func (m *UserMutation) ResetOauthToken() {
	m.oauth_token = nil
	m.clearedoauth_token = false
}

// AddCalendarIDs adds the "calendars" edge to the Calendar entity by ids.
func (m *UserMutation) AddCalendarIDs(ids ...uuid.UUID) {
	if m.calendars == nil {
		m.calendars = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.calendars[ids[i]] = struct{}{}
	}
}

// ClearCalendars clears the "calendars" edge to the Calendar entity.
func (m *UserMutation) ClearCalendars() {
	m.clearedcalendars = true
}

// CalendarsCleared reports if the "calendars" edge to the Calendar entity was cleared.
func (m *UserMutation) CalendarsCleared() bool {
	return m.clearedcalendars
}

// RemoveCalendarIDs removes the "calendars" edge to the Calendar entity by IDs.
func (m *UserMutation) RemoveCalendarIDs(ids ...uuid.UUID) {
	if m.removedcalendars == nil {
		m.removedcalendars = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.calendars, ids[i])
		m.removedcalendars[ids[i]] = struct{}{}
	}
}

// RemovedCalendars returns the removed IDs of the "calendars" edge to the Calendar entity.
func (m *UserMutation) RemovedCalendarsIDs() (ids []uuid.UUID) {
	for id := range m.removedcalendars {
		ids = append(ids, id)
	}
	return
}

// CalendarsIDs returns the "calendars" edge IDs in the mutation.
func (m *UserMutation) CalendarsIDs() (ids []uuid.UUID) {
	for id := range m.calendars {
		ids = append(ids, id)
	}
	return
}

// ResetCalendars resets all changes to the "calendars" edge.
func (m *UserMutation) ResetCalendars() {
	m.calendars = nil
	m.clearedcalendars = false
	m.removedcalendars = nil
}

// Where appends a list predicates to the UserMutation builder.
func (m *UserMutation) Where(ps ...predicate.User) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the UserMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *UserMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.User, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *UserMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *UserMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (User).
func (m *UserMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *UserMutation) Fields() []string {
	fields := make([]string, 0, 3)
	if m.email != nil {
		fields = append(fields, user.FieldEmail)
	}
	if m.refresh_token != nil {
		fields = append(fields, user.FieldRefreshToken)
	}
	if m.refresh_token_expiry != nil {
		fields = append(fields, user.FieldRefreshTokenExpiry)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *UserMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case user.FieldEmail:
		return m.Email()
	case user.FieldRefreshToken:
		return m.RefreshToken()
	case user.FieldRefreshTokenExpiry:
		return m.RefreshTokenExpiry()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *UserMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case user.FieldEmail:
		return m.OldEmail(ctx)
	case user.FieldRefreshToken:
		return m.OldRefreshToken(ctx)
	case user.FieldRefreshTokenExpiry:
		return m.OldRefreshTokenExpiry(ctx)
	}
	return nil, fmt.Errorf("unknown User field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserMutation) SetField(name string, value ent.Value) error {
	switch name {
	case user.FieldEmail:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEmail(v)
		return nil
	case user.FieldRefreshToken:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRefreshToken(v)
		return nil
	case user.FieldRefreshTokenExpiry:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRefreshTokenExpiry(v)
		return nil
	}
	return fmt.Errorf("unknown User field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *UserMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *UserMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown User numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *UserMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(user.FieldRefreshToken) {
		fields = append(fields, user.FieldRefreshToken)
	}
	if m.FieldCleared(user.FieldRefreshTokenExpiry) {
		fields = append(fields, user.FieldRefreshTokenExpiry)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *UserMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *UserMutation) ClearField(name string) error {
	switch name {
	case user.FieldRefreshToken:
		m.ClearRefreshToken()
		return nil
	case user.FieldRefreshTokenExpiry:
		m.ClearRefreshTokenExpiry()
		return nil
	}
	return fmt.Errorf("unknown User nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *UserMutation) ResetField(name string) error {
	switch name {
	case user.FieldEmail:
		m.ResetEmail()
		return nil
	case user.FieldRefreshToken:
		m.ResetRefreshToken()
		return nil
	case user.FieldRefreshTokenExpiry:
		m.ResetRefreshTokenExpiry()
		return nil
	}
	return fmt.Errorf("unknown User field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *UserMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.oauth_token != nil {
		edges = append(edges, user.EdgeOauthToken)
	}
	if m.calendars != nil {
		edges = append(edges, user.EdgeCalendars)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *UserMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case user.EdgeOauthToken:
		if id := m.oauth_token; id != nil {
			return []ent.Value{*id}
		}
	case user.EdgeCalendars:
		ids := make([]ent.Value, 0, len(m.calendars))
		for id := range m.calendars {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *UserMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removedcalendars != nil {
		edges = append(edges, user.EdgeCalendars)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *UserMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case user.EdgeCalendars:
		ids := make([]ent.Value, 0, len(m.removedcalendars))
		for id := range m.removedcalendars {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *UserMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedoauth_token {
		edges = append(edges, user.EdgeOauthToken)
	}
	if m.clearedcalendars {
		edges = append(edges, user.EdgeCalendars)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *UserMutation) EdgeCleared(name string) bool {
	switch name {
	case user.EdgeOauthToken:
		return m.clearedoauth_token
	case user.EdgeCalendars:
		return m.clearedcalendars
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *UserMutation) ClearEdge(name string) error {
	switch name {
	case user.EdgeOauthToken:
		m.ClearOauthToken()
		return nil
	}
	return fmt.Errorf("unknown User unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *UserMutation) ResetEdge(name string) error {
	switch name {
	case user.EdgeOauthToken:
		m.ResetOauthToken()
		return nil
	case user.EdgeCalendars:
		m.ResetCalendars()
		return nil
	}
	return fmt.Errorf("unknown User edge %s", name)
}
